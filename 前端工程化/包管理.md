## 深入前端包管理：npm、yarn和pnpm的背后

# 引言

  当我第一次在实验室中上手第一个项目时，包管理着实给我上了一课，我花了整整一个晚上也没能把项目启动起来。只好第二天提着奶茶求助学长把他的`node_modules`拷贝给我，至今难忘项目第一次跑起来的那份激动。言归正传，本文的目标是帮助小白和有一定经验的同学更加了解包管理工具的前世今生，能够在今后的工作运用的更加得心应手。欢迎大家的批评和鼓励，你的建议是我提升文章质量和持续产出的动力之源，好了废话不多说我们开始吧！

# 包管理是什么

## 什么是包？

在软件开发领域，"包"作为一个专业术语，通常是指一组相关的代码块、功能、资源的集合，他们被封装打包用于管理、共享和复用。类比到生活中，就像是简单的分类管理，你可以把日常用品分为一个“包”，可以把游戏机分为一个“包”。分类标准上并没有严格的定义，但往往一个好的分类方式能够受到大多数人的认可，也就慢慢地成为了一种标准。在软件开发中当然也不例外，聪明的先驱者们早已为百花齐放的“包”们制定了一套严格的标准，用于高效地管理、复用，这便是包管理。

## 包管理的定义

包管理是来自项目管理的产物，它的主要作用是管理和维护项目开发中所需的各种依赖项，保障项目构建、运行的高效、可靠。这样描述可能有点抽象，这里结合前端的`npm`包、`Java`的`jar`包和`C++`的动态依赖库来深入探讨一下包管理的概念吧~

### 通用特征

- **依赖管理机制：**前面提到包的分类标准百花齐放，因此会常常存在“站在巨人肩膀之上”的现象，大多数的包是在小包的基础上进行集成的，这些小包便成为了大包的依赖项。对于开发者来说，依赖管理机制就像是一份说明书，其描述了包与包之间的依赖关系以保证项目开发所需要的包都能够被正确地集成进来。
- **版本机制：**以文章开头的例子为例，时隔多月之后我才弄清楚那晚项目跑不起来的原因竟然是有两个子包的版本与学长的不一样所致...因此版本机制的主要作用便是避免开发者陷入不同包版本之间的不兼容问题，说人话就是只要锁定了相同版本的包，项目就一定是可以稳定运行的。
- **更新机制：**一个项目可能依赖了成千上万个包，如果都由开发者进行管理，这无疑是及其低效且不稳定的。（老虎也有打盹的时候）因此更新机制应运而生，开发者只需要管理最上层的应用大包，更新机制会自动解析大包所依赖的子包并进行下载、安装、更新、卸载等操作。

### `JS`中的`npm`包

- **特点：**前端开发中使用`npm`包管理工具，它以`js`库和工具的形式存在。包管理声明文件为`package.json`，通过`npm install`命令进行依赖安装
- **差异：**前端项目的一大特点是涉及大量的依赖，同时`js`社区非常活跃，上至`AIGC`下至进程调度，无所不用其极，包版本的更新频率也是快的飞起，也更加松散。尽管`npm`采用语义化版本控制进行包版本管理，但仍然存在解析依赖和版本冲突解决的挑战。

### `Java`中的`jar`包

- **特点：**在`Java`开发中，`Jar`（`Java Archive`）包包含`Java`类、资源和元数据。包管理通常通过构建工具（如`Maven`）处理，通过中央仓库下载和管理依赖（严重怀疑`pnpm`偷学了一手）
- **差异：**`Java`包管理工具更注重精确的版本管理，可以更好地处理版本冲突。`Java`包的发布和分发通常以统一的标准格式（`JAR`文件）进行。

### `C++`的动态依赖库

- **特点：**`C++`项目通常使用动态链接库或共享库来贡献可执行代码或函数。包管理通常由操作系统或构建工具处理，以确保库文件在系统对应路径或项目指定位置。我印象最深刻的就是刷题中常用的`#include<bits/stdc++.h>`。
- **差异：**正如`C++`的语言特性一样，`C++`的包管理也需要开发者关注更多，包括依赖的路径和编译的过程，并且在跨平台时要考虑到不同操作系统的差异性。简而言之就是给了开发者更大的自由空间和更高的上手度。

## 包管理的历史进程

- **手工下载和管理**：早期的前端开发，开发者需要手动下载和管理所有的依赖文件，包括`HTML`、`CSS`、`JavaScript`等。这种方式效率低下，容易出错。

- **独立工具出现**：随着前端开发的发展，一些独立的包管理工具开始出现，如`Bower`。这些工具允许开发者通过命令行安装、更新和删除前端依赖，提高了开发效率。
- **NPM的崛起**：`NPM（Node Package Manager`）作为`Node.js`的包管理工具，逐渐成为前端开发的主流工具。它不仅用于管理`Node.js`的依赖，还用于管理前端依赖。`NPM`的强大生态系统和易用性使其成为前端包管理的首选工具。
- **Yarn的出现**：`Yarn`是由`Facebook`、`Google`和`Exponent`合作开发的前端包管理工具。它旨在改进`NPM`的性能和稳定性，并引入了一些新特性，如离线安装和更快的下载速度。`Yarn`迅速获得了广泛的认可，与`NPM`之间形成了竞争关系。
- **PNPM的兴起**：`PNPM`是另一种前端包管理工具，与传统的`NPM`和`Yarn`不同，它采用符号链接和硬链接的方式来共享依赖项，节省了磁盘空间，并提供了快速的安装速度。`PNPM`的出现为前端包管理带来了新的选择，尤其在大型项目中表现出色。

- **模块化和构建工具的崛起**：随着前端开发越来越复杂，模块化和构建工具如`Webpack`、`Rollup`、`Vite`也变得至关重要。这些工具帮助开发者将前端代码拆分成模块，然后使用包管理工具来管理这些模块的依赖关系。

- **前端框架的普及**：前端框架如`React`、`Angular`和`Vue.js`的兴起进一步推动了前端包管理工具的发展。这些框架通常有自己的生态系统和依赖关系，需要包管理工具来有效地管理它们。

本文主要介绍项目开发期的包管理工具，关于模块化、构建管理、集成部署、框架等等内容会在之后的内容中慢慢提到~

# 为什么要使用包管理

前端包管理工具在处理项目复杂性、版本控制、开发者协作和生态系统集成等方面发挥了关键作用。它有助于确保前端项目的稳定性、可维护性和可扩展性，同时提供了更高效的开发流程，是现代前端开发的不可或缺的一部分。

- **项目复杂性管理**：前端项目的复杂性不断增加，包括多个页面、组件、第三方库和框架。包管理工具可以帮助开发者有效地管理这些复杂性。通过定义项目依赖和模块化组织代码，开发者可以更轻松地维护和扩展项目，确保代码的**可维护性**。

- **版本控制**：包管理工具允许开发者明确指定项目依赖的版本。这对于版本控制非常重要，因为不同版本的依赖项可能存在**兼容性**问题。通过锁定依赖项的版本，开发者可以确保在不同开发环境和团队成员之间保持一致性，避免潜在的问题。

- **开发者协作**：在团队协作中，多个开发者可能同时参与项目。包管理工具简化了依赖项的共享和安装过程。开发者可以**共享**项目的依赖配置文件（如`package.json`），并使用包管理工具轻松地安装所需的依赖项。这样，团队成员之间可以更好地协作，减少了配置和环境问题。

- **生态系统支持**：前端生态系统不断演进，有大量的开源库、框架和工具可供选择。包管理工具提供了便捷的方式来访问和集成这些资源。开发者可以使用包管理工具来搜索、安装和管理这些第三方资源，加速开发过程，同时也能够受益于社区维护的库的稳定性和更新。

# 深入`npm`

## `npm`简介

`npm`（`Node Package Manager`）正如它的名字一样最初是`Node`包管理工具，后来逐渐扩展到整个`JavaScript`生态系统中。这里我们废话不多说，以一个`demo`为例，讲述`npm`的核心机制和开发者常遇到的应用场景。

## 安装和项目初始化

### 安装`Node`

在安装`Node`后，会顺带安装好`npm`（毕竟`npm`是`node`提供的包管理工具）。访问[`node`中文官网](https://nodejs.cn/)，下载最新稳定包即可。

![image-20230925084328628](C:\Users\win\AppData\Roaming\Typora\typora-user-images\image-20230925084328628.png)

控制台输入`node -v`验证安装是否成功。

![image-20230926085318625](C:\Users\win\AppData\Roaming\Typora\typora-user-images\image-20230926085318625.png)

! 注意：部分老项目会限定`Node`版本，这主要是因为`Node`版本迭代飞快,大版本不兼容升级带来的。那么对于不同项目限定不同`node`版本的情况有什么好的解决方案吗？那当然，`nvm`应运而生。

### `nvm`

#### 安装

`nvm`全称`node version manager`，顾名思义是`node`的版本管理器，它允许我们安装多个`node`版本，并在某个作用域下（如某个项目工作区）锁定`node`版本

`Mac`的配置方法参考之前整理的文章[前端开发必备环境安装（Mac OS）](https://juejin.cn/post/6993632086296887326),这里主要演示一下`windows`系统下如何安装配置`nvm`。



我们直接访问`nvm`的[仓库](https://github.com/coreybutler/nvm-windows/releases)，下载安装包

![image-20230925085132543](C:\Users\win\AppData\Roaming\Typora\typora-user-images\image-20230925085132543.png)

这一步是选择`nvm`安装并链接`node`的路径，我们选择已安装的`node`路径后能一键把当前的`node`版本和`nvm`关联起来

![image-20230925085356599](C:\Users\win\AppData\Roaming\Typora\typora-user-images\image-20230925085356599.png)

![image-20230925085504190](C:\Users\win\AppData\Roaming\Typora\typora-user-images\image-20230925085504190.png)

重新打开控制台验证安装是否成功（要关掉之前的控制台重新打开哦）

![image-20230925085746549](C:\Users\win\AppData\Roaming\Typora\typora-user-images\image-20230925085746549.png)

#### 运用

查看当前版本、已安装过的`node`版本

```
# 查看当前版本
nvm current

# 查看所有版本包括当前版本
nvm list
```

设置镜像源，目的是提升下载的速度

![image-20230926085007872](C:\Users\win\AppData\Roaming\Typora\typora-user-images\image-20230926085007872.png)

```
# 设置node源
nvm node_mirror https://npm.taobao.org/mirrors/node/
# 设置npm源
nvm npm_mirror https://npm.taobao.org/mirrors/npm/
```

安装、卸载指定版本的`node`

```
# 这里的版本号自行指定即可
nvm install 14.0.0

# 卸载
nvm uninstall 14.0.0
```

在当前控制台指定`node`版本，常用于在不同项目间指定`node`版本

注意：这个命令在`windows`和`mac`上表现不一致，`mac`只会在当前工作区生效，而`windows`会全局生效，详情参考[nvm官网](https://github.com/coreybutler/nvm-windows)

```
nvm use 14.0.0
```

全局指定默认`node`版本（仅`mac`，`windows`无该命令）

```
# 这里的版本号自行指定即可
nvm alias default 18.15.0
```

## 包安装和更新

**初始化项目**：创建一个新的`npm`项目，这将自动生成一个`package.json`文件，其中包含项目的元数据和依赖项信息。

```
npm init
```

**安装包**：用于安装`npm`包及其依赖项。你可以通过包名指定要安装的包。

```
npm install 包名
```

- `-g` 标志：全局安装包，而不是项目特定的依赖项。
- `--save` 或 `-S` 标志：将包保存到项目的`dependencies`中。
- `--save-dev` 或 `-D` 标志：将包保存到项目的`devDependencies`中，通常用于开发和构建工具。

这里补充一下`dependencies`和`devDependencies`的区别，前者是项目必备依赖，会随项目源码一起打包；后者是项目开发环境所需依赖，不会在构建阶段打包进正式包。通常`devDependencies`中包含的依赖有项目脚手架、代码检查工具、单测工具等

**卸载包**：从项目中卸载已安装的包。

```
npm uninstall 包名
```

- `--save` 或 `-S` 标志：同时从`dependencies`中卸载。
- `--save-dev` 或 `-D` 标志：同时从`devDependencies`中卸载。

**查看已安装的包**：列出项目中已安装的所有`npm`包及其版本。

```
npm ls
```

**更新包**：将已安装的包升级到其最新版本。

```
npm update 包名
```

- `-g` 标志：全局更新已安装的包。

**运行脚本**：执行在`package.json`中定义的脚本命令，可以自定义各种项目任务，如启动服务器、构建应用程序等。

```
# 脚本存放在 package.json 下的scripts
npm run 脚本名称

# package.json
{
  "name": "fe-engineering",
  "version": "1.0.0",
  "description": "前端工程化",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/wangyangzero/fe-engineering.git"
  },
  "author": "lemon橙汁",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/wangyangzero/fe-engineering/issues"
  },
  "homepage": "https://github.com/wangyangzero/fe-engineering#readme",
  "dependencies": {
    "lodash": "^4.17.21"
  }
}
```

## 依赖管理

### 依赖安装机制

### `npm` 2.x

`npm 2.x`时代，安装依赖的方式比较简单粗暴，会为每个`npm`包安装其所需的依赖从而形成项目依赖树。这样做能够很好地实现依赖隔离，但是缺点也是显而易见的——相同的依赖被安装了多次，降低了开发效率和打包产物的包体积（影响性能）。（如下图）

```
 ---- packageA
|
|
 -------- packageD@0.1.0
|
|
 ---- packageB
|
|
 -------- packageD@0.1.0
|
|
 ---- packageC
|
|
 -------- packageD@0.2.0
```

### `npm` 3.x

`npm 3.x`时代受`yarn`冲击比较大，因而也带了扁平化的依赖安装机制。不同于`2.x`时代深度优先遍历生成树的方式，`3.x`时代采用广度优先方式进行遍历，并且在遍历时将相同依赖打平放到最外层的`node_modules`，不同的依赖仍像`2.x`一样存放在对应`package`下的`node_modules`里。这样做的好处当然是解决`2.x`带来的弊端，但相较于`2.x`文件粒度的依赖隔离，`3.x`在处理相同依赖不同版本之间的兼容性时会更加棘手一点。经过[PandlyShen](https://juejin.cn/user/3632442148923006/posts)的[前端工程化（5）：你所需要的npm知识储备都在这了](https://juejin.cn/post/6844903870578032647)测试，可以得出以下结论：`npm install`时，首先将`package.json`里的依赖按照首字母（@排最前）进行排序，然后将排序后的依赖包按照广度优先遍历的算法进行安装，最先被安装到的模块将会被优先安装在一级`node_modules`目录下。（如下图）

```|
// 假设依赖关系、包的排列顺序如下
 ---- packageA
|
|
 -------- packageD@0.1.0
|
|
 ---- packageB
|
|
 -------- packageD@0.1.0
|
|
 ---- packageC
|
|
 -------- packageD@0.2.0

 
 // 最终安装结构
  ---- packageA
|
|
 ---- packageB
|
|
 ---- packageC
|
|
 -------- packageD@0.2.0
|
|
 ---- packageD@0.1.0
 
 
 // 假设依赖关系、包的排列顺序如下
 ---- packageA
|
|
 -------- packageD@0.1.0
|
|
 ---- packageB
|
|
 -------- packageD@0.1.0
|
|
 ---- packageC
|
|
 -------- packageD@0.2.0
|
|
 ---- packageD@0.3.0
 
 // 最终安装结构,可以发现此时安装后的结构已经退化到2.x了
 ---- packageA
|
|
 -------- packageD@0.1.0
|
|
 ---- packageB
|
|
 -------- packageD@0.1.0
|
|
 ---- packageC
|
|
 -------- packageD@0.2.0
|
|
 ---- packageD@0.3.0
```

### `package-lock.json`

`package-lock.json`的机制有点像`DNS`解析的缓存机制，主要作用有两个：锁定包版本和记录包的下载地址。

- 锁包：锁包意味着只要使用同一份配置，无论开发者本地的开发环境如何，最终下载到的包依赖版本都是一致的。这样可以有效避免因为开发环境等原因造成的包依赖版本不一致的工程问题
- 记录包下载地址：最大的好处就是快！无需再去读取包的`package.json`文件，无需再去进行依赖分析、无需再去搜索下载依赖。其中`integrity`是一个`hash`值，主要作用是验证包的有效性。（每一个包版本都会生成一个验证其有效的`hash`值）

```
{
  "name": "fe-engineering",
  "version": "1.0.0",
  "lockfileVersion": 1,
  "requires": true,
  "dependencies": {
    "lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg=="
    }
  }
}
```

### `dependencies`

终于到了项目依赖声明这部分了，我的观点是抛开业务场景讲`dependencies`都是耍流氓，因此下面是一些常备的业务场景。

#### 业务开发场景

业务开发时，通常只会用到`npm`包，常接触的有`dependencies`、`devDependencies`和`resolutions`

- `dependencies`：项目强依赖，会打包集成到最终产物中，是业务源码中不可获取的一部分。当然因为直属依赖包下又依赖很多子包，并非所有的子包都有必要打包到最终产物中（如前文安装造成的重复包等），打包阶段有一个`tree shaking`的机制，这个机制将在后续打包文章中进行分享。

- `devDependencies`：本地开发环境依赖，不会打包集成到最终产物中，仅供开发环境使用。通常是一些稳定性检查、格式检查工具，如`eslint`、`prettier`、`jest`等等

- `resolutions`：作用是锁定依赖版本。比如当前项目有`A@2.0.0`、`B@1.0.0`、`C@2.0.0`，其中`A`包依赖了`C@1.0.0`，`B `包依赖了`A@1.0.0`。通常我们会取所有公共依赖中版本最高的那个，因此`resolutions`配置如下，这样在装包时只会装`resolutions`里面指定的版本，不会多装。

  ```
  {
  	"resolutions": {
  		"A": "2.0.0",
  		"C": "2.0.0"
  	}
  }
  ```

#### 公共包维护场景

相比于业务常用场景，额外增加了对`peerDependencies`的使用。

`peerDependencies`的作用是对于同一个`npm`包在公共包依赖的包版本和项目依赖的包版本不一致是优先取项目里配置的依赖的版本，这个特性能在很大程度上增强公共包的适配性。当然遇到版本冲突时`resolutions`始终是一个万能解决方案。

### `scripts`

`scripts`的主要目的有两个：一是配置在`package.json`中，清晰明了；二是简化执行`node`脚本的命令

```
  "scripts": {
    "start": "node scripts/start.js",
    "build": "node scripts/build.js",
    "test": "node scripts/test.js"
  }
```

### `version`、`tag`

`npm`采用`semver`语义化版本规范，以下是基本介绍。

#### 版号格式

一个完整的版本号由三部分组成`major.minor.patch`

- 主版本号（`major`）：做了不向前兼容的修改
- 次版本号（`minor`）：做了向前兼容的修改，并且是稳定的新增功能
- 修订号（`patch`）：做了向前兼容的修改，通常包含新功能特性和问题修复，但不保证版本的稳定性

- 先行版本号（`pre-release version`）：通常作为发布正式版之前的版本，常用的规范是`1.0.0-alpha.0`、`1.0.0-beta.0`，表示是预发布的测试版本.

#### 依赖中的版号规则

- `1.0.0`：安装指定版本
- `^1.0.0`：可以安装`1.0.0`及其以上版本
- `>1.0.0`：安装`1.0.0`以上版本，`>`、`<`、`=`、`>=`、`<=`同理
- `1.0.0 || 2.0.0`：逻辑或
- `*`：通配符，表示可安装任意版本，通常会安装`latest` `tag`的版本
- `1.x`：表示可以安装主版本号为 `1` 的任意版本，`1.0.x`同理 

#### 标签规范

- `latest`：当你使用`npm publish`发布一个`npm`包会自动给这个包版本打上`latest` `tag`，即这是最新版本的包

- 语义`tag`：这个跟项目诉求有关，通常要求`tag`具有一定的语义，如`beta`、`alpha`表示测试包；`release`表示稳定包。想要手动指定添加/移除某个`tag`,参考下面命令。

  ```
  # 查看包有哪些tag
  npm dist-tag ls [<package-spec>]
  
  # 添加tag
  npm dist-tag add <package-spec (with version)> [<tag>]
  
  # 移除tag
  npm dist-tag rm <package-spec> <tag>
  ```

### 第四部分：引申工具 - yarn和pnpm

1. yarn简介
   - 介绍yarn的由来和基本特点
2. yarn vs. npm
   - 对比yarn和npm的区别和优势
3. pnpm简介
   - 介绍pnpm的特点和优势
4. pnpm vs. npm和yarn
   - 对比pnpm与npm、yarn的异同点
5. 如何选择
   - 指导开发者在这些工具之间作出选择

### 第五部分：包管理的最佳实践

1. 版本控制策略
   - 推荐使用语义化版本号（Semantic Versioning）和锁定依赖版本
2. 安全性和漏洞管理
   - 讨论包管理对项目安全性的影响以及如何处理漏洞
3. 包管理的性能优化
   - 提供优化包安装和更新速度的建议
4. 包管理的持续集成（CI/CD）集成
   - 解释如何将包管理与CI/CD流程整合

### 结论

- 总结包管理的关键概念和原理
- 鼓励开发者在前端项目中积极应用包管理工具
- 引导读者深入研究和探索更多高级的包管理主题

### 参考文献

- 列出用于编写本文的参考文献和资源

[前端工程化（5）：你所需要的npm知识储备都在这了](https://juejin.cn/post/6844903870578032647)

[semver 语义化版本规范](https://www.jianshu.com/p/a7490344044f)